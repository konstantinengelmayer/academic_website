[{"content":" Unmarked Assignment: Cleaning Crops In this assignment we read and clean our data to prepare it for data analysis. First we take a look at the data: 1. Problems to solve Skip first 6 and last 5 row of the file Set right encoding to read Umlaute properly Read file with the first 3 column names missing Convert the missing values (“_” and “.” and “/”) to NA Divide column 3 into 3 different columns Fill up the 3 different columns with missing information like “Land” and “Landkreis” Set a new order of the columns and sort the data frame by id and year 2. Problem solving data \u0026lt;- read.csv2(file = \u0026quot;../../data/115-46-4_feldfruechte.txt\u0026quot;, header = TRUE, nrows = 8925, na.strings = c(\u0026quot;.\u0026quot; , \u0026quot;-\u0026quot;, \u0026quot;/\u0026quot;), skip = 6, check.names = FALSE, encoding = 'latin1')\rread.csv2() reads files with following default settings (e.g seperator = “,”, dec = “,”) skip = 6 skips the first 6 rows na.strings = c(“.”, “-”, “/”) repleaces missing values with NA´s check.names = FALSE disables the checking of the column names so it doesn´t produces an error with 3 missing column names encoding = ‘latin1’ allows Umlaute nrow = 8925 ignores the last 5 rows colnames(data)[1:3] \u0026lt;- c(\u0026quot;Jahr\u0026quot;, \u0026quot;ID\u0026quot;, \u0026quot;Ort\u0026quot;)\radds column names for the first 3 columns source(\u0026quot;functions.R\u0026quot;)\rdata$Administrative_Einheit \u0026lt;- NA\rdata$Administrative_Besonderheit \u0026lt;- NA\rdata \u0026lt;- cleaning_administrativ_area(data, data$Ort)\rdata \u0026lt;- data[,c(2,1,3,14,15,4,5,6,7,8,9,10,11,12,13)]\rdata \u0026lt;- data[order(data$ID,data$Jahr), ]\rrownames(data) \u0026lt;- 1:nrow(data)\rreads r-script of the cleaning_administrative_are()-function i created creates new columns for administrative variables cleaning_administrative_area() seperates the “Ort”- column into 3 columns sort and order the dataframe Click here to view the code for the\rcleaning\\_administrative\\_area() -function\r# Define a function to clean administrative area data in a dataframe\rcleaning_administrativ_area \u0026lt;- function(dataframe, column){\r# Split the specified column on commas\rsplit_data \u0026lt;- strsplit(column, \u0026quot;,\u0026quot;)\r# Extract the first, second, and third elements from each split string\rone \u0026lt;- sapply(split_data, function(x) x[1])\rtwo \u0026lt;- sapply(split_data, function(x) x[2])\rthree \u0026lt;- sapply(split_data, function(x) x[3])\r# Create a new data frame from the extracted elements\rdf \u0026lt;- data.frame(one = one, two = two, three = three)\r# Identify rows where the third column is not NA for swapping\rswap_idx \u0026lt;- !is.na(df$three)\r# Perform the swap of 'two' and 'three' where the third column is not NA\rtemp \u0026lt;- df$two[swap_idx]\rdf$two[swap_idx] \u0026lt;- df$three[swap_idx]\rdf$three[swap_idx] \u0026lt;- temp\r# Fill missing values in 'two' based on how far the place is idented\rdf$two[is.na(df$two) \u0026amp; regexpr(\u0026quot;\\\\S\u0026quot;, df$one)==1] \u0026lt;- \u0026quot;Land\u0026quot;\rdf$two[is.na(df$two) \u0026amp; regexpr(\u0026quot;\\\\S\u0026quot;, df$one)==3] \u0026lt;- \u0026quot;Bundesland\u0026quot;\rdf$two[is.na(df$two) \u0026amp; regexpr(\u0026quot;\\\\S\u0026quot;, df$one)==7] \u0026lt;- \u0026quot;Landkreis\u0026quot;\r# Trim leading whitespace from 'one', 'two', and 'three'\rdf$one \u0026lt;- sub(\u0026quot;^\\\\s+\u0026quot;, \u0026quot;\u0026quot;, df$one)\rdf$two \u0026lt;- sub(\u0026quot;^\\\\s+\u0026quot;, \u0026quot;\u0026quot;, df$two)\rdf$three \u0026lt;- sub(\u0026quot;^\\\\s+\u0026quot;, \u0026quot;\u0026quot;, df$three)\r# Update the original dataframe with the new columns\rdataframe$Ort \u0026lt;- df$one\rdataframe$Administrative_Einheit \u0026lt;- df$two\rdataframe$Administrative_Besonderheit \u0026lt;- df$three\r# Return the modified dataframe\rreturn(dataframe)\r}\r","date":"2023-11-13T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/assignment-04-data-analysis/","title":"Assignment 04 - Data analysis"},{"content":" Warm up spatial This is a follow-along exercise to get familiar with handling spatial data in R. First we read our geoAI_setup file to get our directories and load our packages\nsource(\u0026quot;geoAI_setup.R\u0026quot;)\rNow we read our raster excerpt with the rast-function of the terra package.\ndop \u0026lt;- terra::rast(paste0(envrmt$path_data_level1,\u0026quot;/marburg_dop_excerpt.tif\u0026quot;))\rWe download building data from open street map and get the polygons.\nbuildings \u0026lt;- osmdata::opq(bbox = \u0026quot;marburg de\u0026quot;) %\u0026gt;%\rosmdata::add_osm_feature(key = \u0026quot;building\u0026quot;) %\u0026gt;%\rosmdata::osmdata_sf()\rbuildings \u0026lt;- buildings$osm_polygons\rWe check the if the projections are the same and transform them to match.\nterra::same.crs(dop,buildings)\r## [1] FALSE\rbuildings \u0026lt;- sf::st_transform(buildings, terra::crs(dop))\rterra::same.crs(dop,buildings)\r## [1] TRUE\rNow we can take a look at the raster.\nterra::plotRGB(dop)\rWe can calculate different indices with the given bands.\n# Extract individual bands from the DOP for further analysis\rred \u0026lt;- dop[[1]]\rgreen \u0026lt;- dop[[2]]\rblue \u0026lt;- dop[[3]]\r# Calculate the Normalized Difference Turbidity Index (NDTI)\rNDTI \u0026lt;- (red -green) / (red + green)\rnames(NDTI) \u0026lt;- \u0026quot;NDTI\u0026quot;\r# Calculate the Visible Atmospherically Resistant Index (VARI)\rVARI \u0026lt;- (green - red) / (green + red - blue)\rnames(VARI) \u0026lt;- \u0026quot;VARI\u0026quot;\r# Calculate the Triangular Greenness Index (TGI)\rTGI \u0026lt;- -0.5 * (190 * (red - green) - 120 * (red - blue))\rnames(TGI) \u0026lt;- \u0026quot;TGI\u0026quot;\r# Combine the indices into a single stack for plotting\rrgbI \u0026lt;- c(NDTI, VARI, TGI)\rterra::plot(rgbI)\rLastly we can combine the original raster with the newly calculated indicies into object and save it.\ndop_indices \u0026lt;- c(dop, rgbI)\rsaveRDS(dop_indices, file.path(envrmt$path_data, \u0026quot;dop_indices.RDS\u0026quot;))\r","date":"2023-11-12T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/assignment-01-03-geoai/","title":"Assignment 01-03 - GeoAI"},{"content":" Marked Assignment: Read and Plot 1. Task Read the data provided in the Excel file and “isolate” the tabulated information into a data.frame class. First we take a look at the data: We need to read the data with ; as separator and skip the first 4 and the last line of the .txt. Also we set year 2010 to 2014 of colored woods to NA, because they were counted as beechs since 2010.\ndata \u0026lt;- read.table(file = \u0026quot;../../data/hessen_holzeinschlag_1997-2014.csv\u0026quot;, header = TRUE, skip =4, sep = \u0026quot;;\u0026quot;, nrow = 18)\rcolnames(data) \u0026lt;- c(\u0026quot;Year\u0026quot;, \u0026quot;Oak\u0026quot;, \u0026quot;Beech\u0026quot;, \u0026quot;ColoredWoods\u0026quot;, \u0026quot;Spruce\u0026quot;, \u0026quot;Pine\u0026quot;, \u0026quot;Total\u0026quot;)\rdata[which(data$Year\u0026gt; 2009),4] \u0026lt;- NA\rprint(data)\r## Year Oak Beech ColoredWoods Spruce Pine Total\r## 1 1997 155 1036 21 1684 779 3675\r## 2 1998 265 1631 36 1761 951 4644\r## 3 1999 278 1796 32 1732 914 4752\r## 4 2000 204 1300 0 1024 616 3144\r## 5 2001 322 1515 0 1592 706 4135\r## 6 2002 265 1410 0 2036 663 4374\r## 7 2003 404 1698 0 2482 820 5404\r## 8 2004 400 1572 0 2775 757 5504\r## 9 2005 370 1489 0 2601 887 5347\r## 10 2006 388 1881 0 2580 844 5693\r## 11 2007 271 1816 0 6524 782 9393\r## 12 2008 292 1721 0 3698 661 6372\r## 13 2009 135 1149 0 1926 534 3744\r## 14 2010 223 1733 NA 3201 807 5964\r## 15 2011 297 1908 NA 2018 829 5052\r## 16 2012 281 1821 NA 1685 777 4564\r## 17 2013 284 1821 NA 1721 813 4639\r## 18 2014 285 1911 NA 1704 805 4705\r2. Task Create a simple visualization which gives a quick, temporally non explicit and descriptive statistical overview of the harvest by tree type and as a total over all trees (i.e. a similar kind of information as provided by the summary function). I want to create a box plot with the ggplot2 package, grouped by the different tree types. To do that we first need to transform the data frame from the wide to a long format. For that we can use the tidyr package.\nlibrary(tidyr)\rdata_long \u0026lt;- pivot_longer(data, cols = -Year, names_to = \u0026quot;TreeType\u0026quot;, values_to = \u0026quot;Volume\u0026quot;)\rhead(data_long, n = 12)\r## # A tibble: 12 × 3\r## Year TreeType Volume\r## \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt;\r## 1 1997 Oak 155\r## 2 1997 Beech 1036\r## 3 1997 ColoredWoods 21\r## 4 1997 Spruce 1684\r## 5 1997 Pine 779\r## 6 1997 Total 3675\r## 7 1998 Oak 265\r## 8 1998 Beech 1631\r## 9 1998 ColoredWoods 36\r## 10 1998 Spruce 1761\r## 11 1998 Pine 951\r## 12 1998 Total 4644\rNow we can create the box plot and group it by the tree type.\nlibrary(ggplot2)\rggplot(data_long, aes(x = TreeType, y = Volume, group = TreeType)) +\rgeom_boxplot(outlier.shape = NA) +\rgeom_jitter(width = 0.2) + theme_minimal()+\rlabs(x = \u0026quot;Tree Type\u0026quot;, y = expression(Volume~\u0026quot;[1000\u0026quot;~m^3~\u0026quot;]\u0026quot;), title = \u0026quot;Boxplot of Volume by Tree Type in 1000 cubic meter\u0026quot;)\r3. Task Create another visualization which - in the same figure panel - shows how each beech harvest over the time span is related to each of the oak, pine, spruce and colored wood harvests in a 2 by 2 grid (i.e. arrange the figures in a 2 columns and 2 rows layout). This time we will use base R to create the plots. First we create a Layout to arrange to plots in a 2x2 grid, but also add a third row for the legend (so technicly a 2x3 grid). For that we use the layout-function. Inside that function we create a matrix to create different cells for the layout. Because the whole last row should contain the legend we count from 1 to 5 and count 5 two times. We define the number of rows and columns of the layout and adjust the heights of the different rows. Then we can create the plots inside of the layout. At the end we add the legend to the last row.\nlayout(matrix(c(1, 2, 3, 4, 5, 5), 3, 2, byrow = TRUE), heights = c(2, 2, 0.25))\rline_types \u0026lt;- c(\u0026quot;solid\u0026quot;, \u0026quot;dotted\u0026quot;, \u0026quot;dashed\u0026quot;, \u0026quot;dotdash\u0026quot;, \u0026quot;longdash\u0026quot;)\rplot(data$Year, data$Beech, type = \u0026quot;l\u0026quot;, lty = line_types[1], ylim = c(0, 2000),\rxlab = \u0026quot;Year\u0026quot;, ylab = expression(Volume~\u0026quot;[1000\u0026quot;~m^3~\u0026quot;]\u0026quot;), main = \u0026quot;Beech and Oak Volume Over Years\u0026quot;)\rlines(data$Year, data$Oak, lty = line_types[2])\rplot(data$Year, data$Beech, type = \u0026quot;l\u0026quot;, lty = line_types[1], ylim = c(0, 2000), xlab = \u0026quot;Year\u0026quot;, ylab = expression(Volume~\u0026quot;[1000\u0026quot;~m^3~\u0026quot;]\u0026quot;), main = \u0026quot;Beech and Colored Woods Volume Over Years\u0026quot;)\rlines(data$Year, data$ColoredWoods,\rlty = line_types[3])\rplot(data$Year, data$Beech, type = \u0026quot;l\u0026quot;, lty = line_types[1], ylim = c(0, 7000),\rxlab = \u0026quot;Year\u0026quot;, ylab = expression(Volume~\u0026quot;[1000\u0026quot;~m^3~\u0026quot;]\u0026quot;), main = \u0026quot;Beech and Spruce Volume Over Years\u0026quot;)\rlines(data$Year, data$Spruce, lty = line_types[4])\rplot(data$Year, data$Beech, type = \u0026quot;l\u0026quot;, lty = line_types[1], ylim = c(0, 2000),\rxlab = \u0026quot;Year\u0026quot;, ylab = expression(Volume~\u0026quot;[1000\u0026quot;~m^3~\u0026quot;]\u0026quot;), main = \u0026quot;Beech and Pine Volume Over Years\u0026quot;)\rlines(data$Year, data$Pine, lty = line_types[5])\rpar(mar = c(0, 0, 0, 0))\rplot.new()\rlegend(\u0026quot;bottom\u0026quot;, inset = c(0, -0.2), legend = c(\u0026quot;Beech\u0026quot;, \u0026quot;Oak\u0026quot;, \u0026quot;Colored Woods\u0026quot;, \u0026quot;Spruce\u0026quot;, \u0026quot;Pine\u0026quot;), bty = \u0026quot;n\u0026quot;,title = NA, lty = c(line_types[1], line_types[2], line_types[3], line_types[4], line_types[5]), horiz = TRUE)\r4. Task Include your opinion on what could be the key message of these figures in two sentence max. The data shows a notable decrease in spruce harvest volumes in 2007, a result of its vulnerability to factors such as the Kyrill storm, bark beetle infestations, and elevated temperatures. In contrast, other nativ tree species did not exhibit a similar increase in harvest volume that year, underscoring the importance of tailoring forest management to the unique responses of different species to environmental stressors and climate change.\n","date":"2023-11-12T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/assignment-03-data-analysis/","title":"Assignment 03 - Data analysis"},{"content":" Unmarked Assignment: Loop and Conquer 1. Implement an if-then-else statement which prints “larger” if the number provided as variable n is larger than three and “equal or smaller” otherwise. check_value \u0026lt;- function(n){\rif(n \u0026gt;3){\rprint(\u0026quot;large\u0026quot;)\r}else{\rprint(\u0026quot;equal or smaller\u0026quot;)\r}\r}\rcheck_value(2)\r[1] \u0026quot;equal or smaller\u0026quot;\r2. Extent a copy of the above statement (i.e. copy the entire if-then-else statement and include it a second time in your script in order to preserve both versions) which returns “equal” and “smaller” explicitly in addition to “larger”. check_value \u0026lt;- function(n){\rif(n \u0026gt;3){\rprint(\u0026quot;large\u0026quot;)\r}else if(n == 3){\rprint(\u0026quot;equal\u0026quot;)\r}else if(n \u0026lt;3){\rprint(\u0026quot;smaller\u0026quot;)\r}\r}\rcheck_value(2)\r[1] \u0026quot;smaller\u0026quot;\r3. Implement a if-then-else statement which prints “even” if the number provided as variable n is even and which prints “odd” otherwise. even_or_odd \u0026lt;- function(n){\rif(n %% 2 == 0){\rprint(\u0026quot;even\u0026quot;)\r}else{\rprint(\u0026quot;odd\u0026quot;)\r}\r}\reven_or_odd(5)\r[1] \u0026quot;odd\u0026quot;\r4. Copy the extended larger/equal/smaller if-then-else statement and include it into a for loop which shows that all three options are actually implemented in a correct manner by iterating over n from a number which is smaller 3, exactly 3 and larger than 3. check_value \u0026lt;- function(n){\rif(n \u0026gt;3){\rprint(\u0026quot;large\u0026quot;)\r}else if(n == 3){\rprint(\u0026quot;equal\u0026quot;)\r}else if(n \u0026lt;3){\rprint(\u0026quot;smaller\u0026quot;)\r}\r}\rfor(n in c(2,3,4)){\rcheck_value(n)\r}\r[1] \u0026quot;smaller\u0026quot;\r[1] \u0026quot;equal\u0026quot;\r[1] \u0026quot;large\u0026quot;\r5. Extent a copy of the above loop and modify the loop and if-then-else statement in such a way, that the information on “larger” etc. is not printed on the screen but saved within a vector (i.e. a variable which will hold all three statements in the end). Print the content of this vector after the loop. v1 \u0026lt;- c()\rcheck_value \u0026lt;- function(n){\rif(n \u0026gt;3){\rprint(\u0026quot;large\u0026quot;)\r}else if(n == 3){\rprint(\u0026quot;equal\u0026quot;)\r}else if(n \u0026lt;3){\rprint(\u0026quot;smaller\u0026quot;)\r}\r}\rfor(n in c(2,3,4)){\rv1 \u0026lt;- c(v1,check_value(n))\r}\r[1] \u0026quot;smaller\u0026quot;\r[1] \u0026quot;equal\u0026quot;\r[1] \u0026quot;large\u0026quot;\rprint(v1)\r[1] \u0026quot;smaller\u0026quot; \u0026quot;equal\u0026quot; \u0026quot;large\u0026quot; 6. Extent a copy of the above modified loop in such a way, that the results are not saved in a vector but a list. Print the content of this list after the loop. l1 \u0026lt;- list()\rcheck_value \u0026lt;- function(n){\rif(n \u0026gt;3){\rprint(\u0026quot;large\u0026quot;)\r}else if(n == 3){\rprint(\u0026quot;equal\u0026quot;)\r}else if(n \u0026lt;3){\rprint(\u0026quot;smaller\u0026quot;)\r}\r}\rfor(n in c(2,3,4)){\rl1[length(l1) + 1] \u0026lt;- check_value(n)\r}\r[1] \u0026quot;smaller\u0026quot;\r[1] \u0026quot;equal\u0026quot;\r[1] \u0026quot;large\u0026quot;\rprint(l1)\r[[1]]\r[1] \u0026quot;smaller\u0026quot;\r[[2]]\r[1] \u0026quot;equal\u0026quot;\r[[3]]\r[1] \u0026quot;large\u0026quot;\r7. Change the above modified loop in such a way, that the iteration is controlled by a lapply not by a for-loop. Save the returning information from the lapply function in a variable and print the content of this variable after the loop. l1 \u0026lt;- list()\rcheck_value \u0026lt;- function(n){\rif(n \u0026gt;3){# testesttest\rprint(\u0026quot;large\u0026quot;)\r}else if(n == 3){\rprint(\u0026quot;equal\u0026quot;)\r}else if(n \u0026lt;3){\rprint(\u0026quot;smaller\u0026quot;)\r}\r}\rvalues \u0026lt;- c(2,3,4)\rresult \u0026lt;- lapply(values, check_value)\r[1] \u0026quot;smaller\u0026quot;\r[1] \u0026quot;equal\u0026quot;\r[1] \u0026quot;large\u0026quot;\rprint(result)\r[[1]]\r[1] \u0026quot;smaller\u0026quot;\r[[2]]\r[1] \u0026quot;equal\u0026quot;\r[[3]]\r[1] \u0026quot;large\u0026quot;\r8. Finally change the above variable (i.e. do not modify the loop anymore but just include one more line) in such a way that the content is not printed as a nested list but a vector (i.e. flatten the list). check_value \u0026lt;- function(n){\rif(n \u0026gt; 3){\rreturn(\u0026quot;larger\u0026quot;)\r}else if(n == 3){\rreturn(\u0026quot;equal\u0026quot;)\r}else if(n \u0026lt; 3){\rreturn(\u0026quot;smaller\u0026quot;)\r}\r}\rvalues \u0026lt;- c(2,3,4)\rresult \u0026lt;- lapply(values, check_value)\rresult \u0026lt;- unlist(result)\rprint(result)\r[1] \u0026quot;smaller\u0026quot; \u0026quot;equal\u0026quot; \u0026quot;larger\u0026quot; ","date":"2023-11-07T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/assignment-02-data-analysis/","title":"Assignment 02 - Data analysis"},{"content":"Marked Assignment: Hello R, Hello GitHub 1. Assign the value of five to a variable called a and the value of two to a variable called b. a \u0026lt;- 5\rb \u0026lt;- 2\r2. Compute the sum, difference, product and ratio of a and b (a always in the first place) and store the results to four different variables called r1, r2, r3, and r4. r1 \u0026lt;- a+b\rr2 \u0026lt;- a-b\rr3 \u0026lt;- a*b\rr4 \u0026lt;- a/b\r3. Create a vector v1 which contains the values stored within the four variables from step 2. v1 \u0026lt;- c(r1,r2,r3,r4)\r4. Add a fifth entry to vector v1 which represents a by the power of b (i.e. a**b). v1 \u0026lt;- c(v1,a**b)\r5. Show the content of vector v1 (e.g. use the print function or just type the variable name in a separate row). print(v1)\r## [1] 7.0 3.0 10.0 2.5 25.0\r6. Create a second vector v2 which contains information on the type of mathematical operation used to derive the five results. Hence this vector should have five entries of values sum, difference,… v2 \u0026lt;- c(\u0026quot;sum\u0026quot;, \u0026quot;difference\u0026quot;, \u0026quot;product\u0026quot;, \u0026quot;ratio\u0026quot;, \u0026quot;exponentiation\u0026quot;)\r7. Show the content of vector v2. print(v2)\r## [1] \u0026quot;sum\u0026quot; \u0026quot;difference\u0026quot; \u0026quot;product\u0026quot; \u0026quot;ratio\u0026quot; \u0026quot;exponentiation\u0026quot;\r8. Combine the two vectors v1 and v2 into a data frame called df. Each vector should become one column of the data frame so you will end up with a data frame having 5 rows and 2 columns. df \u0026lt;- data.frame(v1,v2)\r9. Make sure that the column with the data of v1 is named Results and v2 is named Operation. colnames(df) \u0026lt;- c(\u0026quot;Results\u0026quot;, \u0026quot;Operation\u0026quot;)\r10. Show the entire content of df. print(df)\r## Results Operation\r## 1 7.0 sum\r## 2 3.0 difference\r## 3 10.0 product\r## 4 2.5 ratio\r## 5 25.0 exponentiation\r11. Show just the entry of the cell in the second row and first column. print(df[2,1])\r## [1] 3\r","date":"2023-10-31T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/assignment-01-data-analysis/","title":"Assignment 01 - Data analysis"}]